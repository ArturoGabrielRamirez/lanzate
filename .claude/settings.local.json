{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(bunx next build:*)",
      "Bash(npx tsc:*)",
      "Bash(git stash:*)",
      "Bash(mkdir:*)",
      "Bash(rm:*)",
      "Bash(bunx tsc:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "WebFetch(domain:ui.shadcn.com)",
      "Bash(bunx shadcn@latest add:*)",
      "Bash(bun x shadcn@latest add:*)",
      "Bash(tree:*)",
      "Bash(grep:*)",
      "Bash(bunx eslint:*)",
      "Bash(test:*)",
      "Bash(mcp list-tools:*)",
      "WebSearch",
      "Bash(claude mcp list:*)",
      "WebFetch(domain:developers.notion.com)",
      "Bash(claude mcp:*)",
      "Bash(echo:*)",
      "Bash(cat:*)",
      "Bash(ls:*)",
      "Bash(bun run build:*)",
      "Bash(timeout 15 bun run dev:*)",
      "Bash(bun add:*)",
      "Bash(bunx:*)",
      "Bash(curl:*)",
      "WebFetch(domain:supabase.com)",
      "WebFetch(domain:github.com)",
      "Bash(bun test:*)",
      "Bash(timeout 120 bun run:*)",
      "Bash(timeout 60 bun run build:*)",
      "Bash(timeout 10 bun run dev:*)",
      "Bash(bun run lint)",
      "Bash(bun x:*)",
      "Bash(find:*)",
      "Bash(npm test:*)",
      "Bash(npm run:*)",
      "Bash(\"E:/personal-dev/lanzate/features/auth/schemas/auth.schema.ts\" <<'EOF'\n/**\n * Authentication Validation Schemas\n *\n * This file composes complete validation schemas for all authentication\n * use cases by combining the reusable field validators from authFields.ts.\n *\n * Each schema is tailored to its specific use case:\n * - signupSchema: Full validation for new user registration\n * - loginSchema: Minimal validation (don't reject existing weak passwords)\n * - resetPasswordRequestSchema: Email-only validation\n * - resetPasswordSchema: Password validation for reset flow\n * - updateProfileSchema: Optional email and password validation for profile updates\n *\n * Types are automatically inferred from schemas using yup.InferType\n * to ensure type safety across the application.\n */\n\nimport * as yup from 'yup';\n\nimport { emailField, passwordField } from '@/features/auth/schemas/authFields';\n\n/**\n * Signup Schema\n *\n * Validates new user registration with:\n * - Valid email format (lowercase, trimmed)\n * - Strong password (8+ chars, uppercase, number)\n * - Matching password confirmation\n */\nexport const signupSchema = yup.object({\n  email: emailField.required('El email es obligatorio'),\n  password: passwordField.required('La contraseña es obligatoria'),\n  confirmPassword: yup\n    .string()\n    .oneOf([yup.ref('password')], 'Las contraseñas no coinciden')\n    .required('Debes confirmar la contraseña'),\n});\n\n/**\n * Login Schema\n *\n * Validates login credentials with minimal requirements:\n * - Valid email format\n * - Password presence (no strength validation)\n *\n * We don't validate password strength on login to avoid\n * rejecting existing users with weaker passwords\n */\nexport const loginSchema = yup.object({\n  email: emailField.required('El email es obligatorio'),\n  password: yup.string().required('La contraseña es obligatoria'),\n});\n\n/**\n * Password Reset Request Schema\n *\n * Validates password reset request with:\n * - Valid email format only\n *\n * Used when user requests a password reset link\n */\nexport const resetPasswordRequestSchema = yup.object({\n  email: emailField.required('El email es obligatorio'),\n});\n\n/**\n * Password Reset Schema\n *\n * Validates password reset form with:\n * - Strong new password (8+ chars, uppercase, number)\n * - Matching password confirmation\n *\n * Used when user sets a new password via reset link\n */\nexport const resetPasswordSchema = yup.object({\n  password: passwordField.required('La contraseña es obligatoria'),\n  confirmPassword: yup\n    .string()\n    .oneOf([yup.ref('password')], 'Las contraseñas no coinciden')\n    .required('Debes confirmar la contraseña'),\n});\n\n/**\n * Update Profile Schema\n *\n * Validates profile update with optional fields:\n * - Email (optional, but must be valid if provided)\n * - Password (optional, but must be strong if provided)\n * - Confirm password (required if password is provided)\n *\n * Used when user updates their profile information\n */\nexport const updateProfileSchema = yup.object({\n  email: emailField.optional(),\n  password: passwordField.optional(),\n  confirmPassword: yup\n    .string()\n    .when('password', {\n      is: (password: string | undefined) => password && password.length > 0,\n      then: (schema) => schema\n        .oneOf([yup.ref('password')], 'Las contraseñas no coinciden')\n        .required('Debes confirmar la contraseña'),\n      otherwise: (schema) => schema.optional(),\n    }),\n}).test(\n  'at-least-one-field',\n  'Debes proporcionar al menos un campo para actualizar',\n  (value) => !!(value.email || value.password)\n);\n\n/**\n * Inferred TypeScript types from schemas\n *\n * These types are automatically generated from the Yup schemas\n * and ensure type safety when using these schemas in forms\n * and server actions\n */\nexport type SignupInput = yup.InferType<typeof signupSchema>;\nexport type LoginInput = yup.InferType<typeof loginSchema>;\nexport type ResetPasswordRequestInput = yup.InferType<typeof resetPasswordRequestSchema>;\nexport type ResetPasswordInput = yup.InferType<typeof resetPasswordSchema>;\nexport type UpdateProfileInput = yup.InferType<typeof updateProfileSchema>;\nEOF)",
      "Bash(\"E:/personal-dev/lanzate/features/auth/actions/updateProfile.action.ts\" <<'EOF'\n'use server';\n\nimport { revalidatePath } from 'next/cache';\n\nimport { AUTH_SUCCESS_MESSAGES } from '@/features/auth/constants/messages';\nimport {\n  updateProfileSchema,\n  type UpdateProfileInput,\n} from '@/features/auth/schemas/auth.schema';\nimport { updateUserProfileService } from '@/features/auth/services';\nimport { actionWrapper } from '@/features/global/utils/action-wrapper';\nimport { formatSuccess } from '@/features/global/utils/format-response';\nimport { createClient } from '@/lib/supabase/server';\n\n/**\n * Update Profile Server Action\n *\n * Updates the user's profile information including email and/or password.\n * Updates both Supabase Auth and the database record.\n *\n * Flow:\n * 1. Validate input with updateProfileSchema\n * 2. Get current authenticated user\n * 3. Update via updateUserProfileService (handles Supabase and database)\n * 4. Revalidate /profile path\n * 5. Return success response\n *\n * Security:\n * - User must be authenticated\n * - At least one field (email or password) must be provided\n * - Password must meet strength requirements if provided\n *\n * @param input - Profile update data (email?, password?, confirmPassword?)\n * @returns ServerResponse with updated user data or error\n *\n * @example\n * ```tsx\n * import { updateProfileAction } from '@/features/auth/actions/updateProfile.action';\n *\n * // Update only email\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com'\n * });\n *\n * // Update only password\n * const result = await updateProfileAction({\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * // Update both email and password\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com',\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * if (!result.hasError) {\n *   // Profile updated successfully\n *   console.log('Updated user:', result.payload?.user);\n * }\n * ```\n */\nexport async function updateProfileAction(input: UpdateProfileInput) {\n  return actionWrapper(async () => {\n    // Validate input with Yup schema\n    // This will throw ValidationError if invalid, caught by actionWrapper\n    const validatedData = await updateProfileSchema.validate(input);\n\n    const { email, password } = validatedData;\n\n    // Create Supabase client\n    const supabase = await createClient();\n\n    // Get current authenticated user\n    const {\n      data: { user: authUser },\n      error: authError,\n    } = await supabase.auth.getUser();\n\n    if (authError) {\n      throw new Error(authError.message);\n    }\n\n    if (!authUser) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Get database user ID from Supabase user metadata or database lookup\n    // We need the database user ID to update the record\n    const { data: dbUserData, error: dbUserError } = await supabase\n      .from('User')\n      .select('id')\n      .eq('supabaseId', authUser.id)\n      .single();\n\n    if (dbUserError || !dbUserData) {\n      throw new Error('Database user not found');\n    }\n\n    // Prepare update parameters\n    const updateParams: { email?: string; password?: string } = {};\n\n    if (email) {\n      updateParams.email = email;\n    }\n\n    if (password) {\n      updateParams.password = password;\n    }\n\n    // Update user profile via service layer\n    // Service handles both Supabase auth and database updates\n    const updatedUser = await updateUserProfileService(\n      dbUserData.id,\n      updateParams\n    );\n\n    // Revalidate profile path to ensure fresh data\n    revalidatePath('/profile');\n\n    // Determine success message based on what was updated\n    let successMessage = AUTH_SUCCESS_MESSAGES.PROFILE_UPDATE.en;\n    if (email && !password) {\n      successMessage = AUTH_SUCCESS_MESSAGES.EMAIL_UPDATE.en;\n    } else if (password && !email) {\n      successMessage = AUTH_SUCCESS_MESSAGES.PASSWORD_UPDATE.en;\n    }\n\n    // Return success response\n    return formatSuccess(successMessage, {\n      user: updatedUser,\n      authUser,\n    });\n  });\n}\nEOF)",
      "Bash(\"E:/personal-dev/lanzate/features/auth/actions/index.ts\" <<'EOF'\n/**\n * Auth actions index file\n *\n * Exports all Server Actions for the auth feature\n */\n\nexport { logoutAction } from \"@/features/auth/actions/logout.action\";\nexport { handleSignupAction } from \"@/features/auth/actions/handleSignup.action\";\nexport { handleLoginAction } from \"@/features/auth/actions/handleLogin.action\";\nexport { handleResetPasswordRequestAction } from \"@/features/auth/actions/handleResetPasswordRequest.action\";\nexport { handleGoogleLoginAction } from \"@/features/auth/actions/handleGoogleLogin.action\";\nexport { handleResetPasswordAction } from \"@/features/auth/actions/handleResetPassword.action\";\nexport { handleLogoutAction } from \"@/features/auth/actions/handleLogout.action\";\nexport { getCurrentUserAction } from \"@/features/auth/actions/getCurrentUser.action\";\nexport { updateProfileAction } from \"@/features/auth/actions/updateProfile.action\";\nEOF)",
      "Bash(\"E:/personal-dev/lanzate/features/auth/actions/updateProfile.action.ts\" <<'EOF'\n'use server';\n\nimport { revalidatePath } from 'next/cache';\n\nimport { AUTH_SUCCESS_MESSAGES } from '@/features/auth/constants/messages';\nimport { getUserBySupabaseId } from '@/features/auth/data';\nimport {\n  updateProfileSchema,\n  type UpdateProfileInput,\n} from '@/features/auth/schemas/auth.schema';\nimport { updateUserProfileService } from '@/features/auth/services';\nimport { actionWrapper } from '@/features/global/utils/action-wrapper';\nimport { formatSuccess } from '@/features/global/utils/format-response';\nimport { createClient } from '@/lib/supabase/server';\n\n/**\n * Update Profile Server Action\n *\n * Updates the user's profile information including email and/or password.\n * Updates both Supabase Auth and the database record.\n *\n * Flow:\n * 1. Validate input with updateProfileSchema\n * 2. Get current authenticated user\n * 3. Fetch database user via getUserBySupabaseId\n * 4. Update via updateUserProfileService (handles Supabase and database)\n * 5. Revalidate /profile path\n * 6. Return success response\n *\n * Security:\n * - User must be authenticated\n * - At least one field (email or password) must be provided\n * - Password must meet strength requirements if provided\n *\n * @param input - Profile update data (email?, password?, confirmPassword?)\n * @returns ServerResponse with updated user data or error\n *\n * @example\n * ```tsx\n * import { updateProfileAction } from '@/features/auth/actions/updateProfile.action';\n *\n * // Update only email\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com'\n * });\n *\n * // Update only password\n * const result = await updateProfileAction({\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * // Update both email and password\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com',\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * if (!result.hasError) {\n *   // Profile updated successfully\n *   console.log('Updated user:', result.payload?.user);\n * }\n * ```\n */\nexport async function updateProfileAction(input: UpdateProfileInput) {\n  return actionWrapper(async () => {\n    // Validate input with Yup schema\n    // This will throw ValidationError if invalid, caught by actionWrapper\n    const validatedData = await updateProfileSchema.validate(input);\n\n    const { email, password } = validatedData;\n\n    // Create Supabase client\n    const supabase = await createClient();\n\n    // Get current authenticated user\n    const {\n      data: { user: authUser },\n      error: authError,\n    } = await supabase.auth.getUser();\n\n    if (authError) {\n      throw new Error(authError.message);\n    }\n\n    if (!authUser) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Fetch database user record via data layer\n    const dbUser = await getUserBySupabaseId(authUser.id);\n\n    // Prepare update parameters\n    const updateParams: { email?: string; password?: string } = {};\n\n    if (email) {\n      updateParams.email = email;\n    }\n\n    if (password) {\n      updateParams.password = password;\n    }\n\n    // Update user profile via service layer\n    // Service handles both Supabase auth and database updates\n    const updatedUser = await updateUserProfileService(\n      dbUser.id,\n      updateParams\n    );\n\n    // Revalidate profile path to ensure fresh data\n    revalidatePath('/profile');\n\n    // Determine success message based on what was updated\n    let successMessage = AUTH_SUCCESS_MESSAGES.PROFILE_UPDATE.en;\n    if (email && !password) {\n      successMessage = AUTH_SUCCESS_MESSAGES.EMAIL_UPDATE.en;\n    } else if (password && !email) {\n      successMessage = AUTH_SUCCESS_MESSAGES.PASSWORD_UPDATE.en;\n    }\n\n    // Return success response\n    return formatSuccess(successMessage, {\n      user: updatedUser,\n      authUser,\n    });\n  });\n}\nEOF)",
      "Bash(\"E:/personal-dev/lanzate/features/auth/actions/updateProfile.action.ts\" <<'EOF'\n'use server';\n\nimport { revalidatePath } from 'next/cache';\n\nimport { AUTH_SUCCESS_MESSAGES } from '@/features/auth/constants/messages';\nimport { getUserBySupabaseId } from '@/features/auth/data';\nimport {\n  updateProfileSchema,\n  type UpdateProfileInput,\n} from '@/features/auth/schemas/auth.schema';\nimport { updateUserProfileService } from '@/features/auth/services';\nimport { actionWrapper } from '@/features/global/utils/action-wrapper';\nimport { formatSuccess } from '@/features/global/utils/format-response';\nimport { createClient } from '@/lib/supabase/server';\n\n/**\n * Update Profile Server Action\n *\n * Updates the user's profile information including email and/or password.\n * Updates both Supabase Auth and the database record.\n *\n * Flow:\n * 1. Validate input with updateProfileSchema\n * 2. Get current authenticated user\n * 3. Fetch database user via getUserBySupabaseId\n * 4. Update via updateUserProfileService (handles Supabase and database)\n * 5. Revalidate /profile path\n * 6. Return success response\n *\n * Security:\n * - User must be authenticated\n * - At least one field (email or password) must be provided\n * - Password must meet strength requirements if provided\n *\n * @param input - Profile update data (email?, password?, confirmPassword?)\n * @returns ServerResponse with updated user data or error\n *\n * @example\n * ```tsx\n * import { updateProfileAction } from '@/features/auth/actions/updateProfile.action';\n *\n * // Update only email\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com'\n * });\n *\n * // Update only password\n * const result = await updateProfileAction({\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * // Update both email and password\n * const result = await updateProfileAction({\n *   email: 'newemail@example.com',\n *   password: 'NewPassword123',\n *   confirmPassword: 'NewPassword123'\n * });\n *\n * if (!result.hasError) {\n *   // Profile updated successfully\n *   console.log('Updated user:', result.payload?.user);\n * }\n * ```\n */\nexport async function updateProfileAction(input: UpdateProfileInput) {\n  return actionWrapper(async () => {\n    // Validate input with Yup schema\n    // This will throw ValidationError if invalid, caught by actionWrapper\n    const validatedData = await updateProfileSchema.validate(input);\n\n    const { email, password } = validatedData;\n\n    // Create Supabase client\n    const supabase = await createClient();\n\n    // Get current authenticated user\n    const {\n      data: { user: authUser },\n      error: authError,\n    } = await supabase.auth.getUser();\n\n    if (authError) {\n      throw new Error(authError.message);\n    }\n\n    if (!authUser) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Fetch database user record via data layer\n    const dbUser = await getUserBySupabaseId(authUser.id);\n\n    // Prepare update parameters\n    const updateParams: { email?: string; password?: string } = {};\n\n    if (email) {\n      updateParams.email = email;\n    }\n\n    if (password) {\n      updateParams.password = password;\n    }\n\n    // Update user profile via service layer\n    // Service handles both Supabase auth and database updates\n    const updatedUser = await updateUserProfileService(\n      dbUser.id,\n      updateParams\n    );\n\n    // Revalidate profile path to ensure fresh data\n    revalidatePath('/profile');\n\n    // Determine success message based on what was updated\n    let successMessage: string = AUTH_SUCCESS_MESSAGES.PROFILE_UPDATE.en;\n    if (email && !password) {\n      successMessage = AUTH_SUCCESS_MESSAGES.EMAIL_UPDATE.en;\n    } else if (password && !email) {\n      successMessage = AUTH_SUCCESS_MESSAGES.PASSWORD_UPDATE.en;\n    }\n\n    // Return success response\n    return formatSuccess(successMessage, {\n      user: updatedUser,\n      authUser,\n    });\n  });\n}\nEOF)",
      "Bash(npm run test:*)",
      "Bash(python3:*)"
    ],
    "deny": [],
    "ask": []
  },
  "spinnerTipsEnabled": true
}

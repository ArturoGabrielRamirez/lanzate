---
alwaysApply: true
---

## 1. Code Organization and Structure

### General Style

- Always use TypeScript for type safety. Provide appropriate type definitions and interfaces.

### Feature General Rules

- All features go inside the `features` folder
- Each requirement must have a feature
- If a requirement can be divided into multiple features, it must be divided into multiple features
- If a requirement already has a feature, it must be added to the existing feature
- All features must have subdirectories inside the `features` folder
- Each feature subdirectory should have an index.ts file that exports all the functions/components of the subdirectory so it can be imported in the feature index.ts file like this:

```tsx
import { component1, component2 } from "@/features/feature-name/components";
```
- When importing from a feature, use the following import convention: 

```tsx
import { pieceName } from '@/features/feature-name/piece-name';
```

### Feature Directory Structure

  • `components/` → UI components of the feature
  • `actions/` → functions of action / server logic. They would be like "controllers" in MVC. They are the functions that are responsible for the "backend" logic of the feature as database operations, validations, etc.
  • `data/` → database access / queries logic. They would be like "models" in MVC. They are the functions that are responsible for database queries in general, but without validations or business logic.
  • `access/` → functions of permission validation. They are the functions that are responsible for validating the permissions of the user for that feature by verifying their role and role permissions.
  • `types/` → specific TS types. They are the types of data that are used in the feature as component props, function parameters, etc.
  • `schemas/` → validation schemas of yup/zod if applicable. They are the validation schemas of the data that are used in the feature as validation schemas of form inputs, or of the body of an api.
  • `utils/` → utility functions that do not belong to any other folder. They are the functions that are used in the feature but do not belong to any other folder, for example functions to format data.
  • `hooks/` → react hooks that are used in the feature.


### File Naming Conventions

*   **Components:** `component-name.tsx`
*   **Actions:** `action-name.action.ts`
*   **Data:** `data-name.data.ts`
*   **Access:** `access-name.access.ts`
*   **Pages:** `page.tsx`
*   **Layouts:** `layout.tsx`
*   **API Routes:** `route.ts`
*   **Hooks:** `use-hook-name.ts`


### Component Architecture

*   **Presentational vs. Container Components:** Separate components that handle data fetching (container server components) from those that only render UI and handle events and state management(presentational client components).
*   **Atomic Design:** Organize components into atoms, molecules, organisms, templates, and pages for better reusability and maintainability.
*   **Explicit typing:** Use `React.FC` or `React.ReactNode` for explicit typing only when necessary, avoiding `JSX.Element`.
*   **Props:** Use interface definitions for props:
*   **Composition over inheritance:** Favor composition to create flexible and reusable components.
*   **Server Components:**  Use server components by default for improved performance.  Only use client components when interactivity (event handlers, useState, useEffect) is required.
*  **Server Component:** If the component should get data from the server, use an async Server Component that calls an awaited action function like this : 
```tsx
export const pageComponentName = async () => {
    return (
        <Suspense fallback={<LoadingComponentSkeleton />}>
            <ContainerComponentName />
        </Suspense>
    );
}
```

```tsx
export const ContainerComponentName = async () => {
    const { payload, hasError, error, message } = await actionNameAction();
    if (hasError) {
        return <div>{error}</div>;
    }
    return <PresentationalComponentName data={payload} />;
}
```
```tsx
export const PresentationalComponentName = ({ data }: { data: any }) => {
    return (
        <div>
        {data}
        {/* if needed a client component
        <ClientComponentName />
        */}
        </div>
    );
}
```
*  **Suspense:** For each Server Component that has an asynchronous process, a <Suspense> must be implemented to handle the loading state, and a Loading component with similar UI to the final component of the asynchronous process
*  **Skeleton Loader:**  The loaders for Server Components for cards, sections, etc, must be Skeleton Loader
*  **SSG/SSR:** Implement Static Site Generation (SSG) and Server-Side Rendering (SSR) using App Router conventions when appropriate.
*  **Wrap in a new component:** Always wrap the return of a .map in a new component
*  **Event callback:** Implement an event callback as a named function following the convention : handle<FeatureName>, eg : handleAddToCartClick, handleCreateNewUserSubmit, handleNameInputChange, etc
*  **Client component:** If a component has an event, only create a client component for that html element that triggers the event if possible, like buttons, inputs, list items, etc
*  **Mark client components explicitly with 'use client'**
*  **useTransition:** Implement useTransition for asynchronous processes
*  **useOptimistic:** Implement useOptimistic for async state updates
* **Flow:** Follow, when possible, to the following flow : 
```
layout > Server Component page > Suspense >Server Component Container > Server Component Presentational > Client Component
```

### Actions Architecture

- Action functions should implement a actionWrapper function like this:
```tsx
export const actionNameAction = async ([...params]) => {
    return actionWrapper(async () => {
        // Action logic
    });
}
```
- Each action function should be placed in its own file in the actions folder of the feature and the file should start with "use server" so the code remains server side.
- If an action function should handle data in any way, it should always call a data function to handle the data, action functions should only be responsible for the business logic and data handling should be handled by data functions.
- Always implement access control in action functions. If no authentication flow is present, implement a dummy access control function that always returns true.
- If there is a mutation in data, use a revalidatePath in the action function  the data in the component/page

### Data Architecture

- Each data function should be placed in its own file in the data folder of the feature and the file should start with "use server" so the code remains server side.



### NextJS Rules

- Use NextJS builed in caching and revalidation features for optimal performance.
- Make sure the metadata of a layout/page has an appropriate title, description, authors, etc


### Code Splitting

*   **Dynamic imports:** Use `next/dynamic` to load components only when they are needed, improving initial load time.  Example: `dynamic(() => import('../components/MyComponent'))`.
*   **Route-level code splitting:** Next.js automatically splits code based on routes, so each page only loads the necessary JavaScript.
*   **Granular code splitting:** Break down large components into smaller chunks that can be loaded independently.



## 2. Common Patterns and Anti-patterns

### Recommended Approaches

*   **Data fetching:** Use `getServerSideProps` or `getStaticProps` or server components for fetching data on the server-side.
*   **Styling:** Use Tailwind CSS for component-level styling.
*   **State Management:** Use React Context for managing global state.
*   **Form Handling:** Use `react-hook-form` for managing forms and validation.
*   **Form Validation:** Use `zod` for form validation.

### Anti-patterns and Code Smells

*   **Over-fetching data:** Only fetch the data that is needed by the component.
*   **Blocking the main thread:** Avoid long-running synchronous operations in the main thread.
*   **Not memoizing components:** Use `React.memo` to prevent unnecessary re-renders.
*   **Writing server side code in client components:** Can expose secrets or cause unexpected behavior.

### Error Handling

*   **`try...catch`:** Use `try...catch` blocks for handling errors in asynchronous operations.
*   **Error Boundary Components:** Create reusable error boundary components to catch errors in child components.
*   **Custom Error Pages:** Use `error.tsx` to create custom error pages.
*   **Route-level error handling:** Use `error.tsx` within route segments to handle errors specific to that route.
* **Page/Component Error Handling:** If a page/component has an error while getting data from the server, the action function should return a error message and a hasError flag to the page/component to be displayed to the user.




## 3. Performance Considerations

### Optimization Techniques

*   **Image optimization:** Use `next/image` component for automatic image optimization, including lazy loading and responsive images.
*   **Font optimization:**  Use `next/font` to optimize font loading and prevent layout shift.
*   **Code splitting:** Use dynamic imports and route-level code splitting to reduce initial load time.
*   **Caching:** Use caching strategies (e.g., `Cache-Control` headers, NextJS built in caching) to reduce data fetching overhead.
*   **Memoization:** Use `React.memo` to prevent unnecessary re-renders of components.
*   **Prefetching:** Use the `<Link prefetch>` tag to prefetch pages that are likely to be visited.
*   **SSR/SSG:** Use Static Site Generation (SSG) for content that doesn't change often and Server-Side Rendering (SSR) for dynamic content.
*   **Incremental Static Regeneration (ISR):** Use ISR to update statically generated pages on a regular interval.

### Memory Management

*   **Avoid memory leaks:** Clean up event listeners and timers in `useEffect` hooks.
*   **Minimize re-renders:** Only update state when necessary to reduce the number of re-renders.
*   **Use immutable data structures:** Avoid mutating data directly to prevent unexpected side effects.

### Rendering Optimization

*   **Server Components:**  Render as much as possible on the server to reduce client-side JavaScript.
*   **Client Components:** Only use client components when interactivity is required. Defer rendering of non-critical client components using `React.lazy` or `next/dynamic`.
*   **Suspense Skeleton Fallback:** Use a Skeleton Loader as a fallback for the Suspense component. Keep as much as possible of the UI of the final component outside the Skeleton Loader, so the user can see part of the UI while the data is loading.

### Bundle Size Optimization

*   **Remove unused code:** Use tree shaking to remove unused code from your bundles.
*   **Use smaller dependencies:** Replace large dependencies with smaller, more lightweight alternatives.



## 4. Security Best Practices

### Common Vulnerabilities

*   **Cross-Site Scripting (XSS):** Sanitize user input to prevent XSS attacks.  Be especially careful when rendering HTML directly from user input.
*   **Cross-Site Request Forgery (CSRF):** Use CSRF tokens to protect against CSRF attacks.
*   **SQL Injection:** Use parameterized queries or an ORM to prevent SQL injection attacks.
*   **Authentication and Authorization vulnerabilities:** Implement secure authentication and authorization mechanisms.  Avoid storing secrets in client-side code.
*   **Exposing sensitive data:** Protect API keys and other sensitive data by storing them in environment variables and accessing them on the server-side.

### Input Validation

*   **Server-side validation:** Always validate user input on the server-side.
*   **Client-side validation:** Use client-side validation for immediate feedback, but don't rely on it for security.
*   **Validation Schema:** Use the same validation schema for server-side and client-side validation, when possible.
*   **Sanitize input:** Sanitize user input to remove potentially malicious code.
*   **Use a validation library:** Use `zod` for validating user input.

### Authentication and Authorization

*   **Implement role-based access control:** Use role-based access control to restrict access to sensitive resources inside the action functions that need it.



## 5. Common Pitfalls and Gotchas

### Frequent Mistakes

*   **Not understanding server-side rendering:**  Failing to utilize SSR effectively can impact SEO and initial load performance.
*   **Over-complicating state management:** Using Redux for simple state management needs can add unnecessary complexity.
*   **Not optimizing images:** Not using `next/image` can result in large image sizes and slow loading times.
*   **Ignoring security best practices:** Neglecting security can lead to vulnerabilities.
*   **Not testing the application thoroughly:** Insufficient testing can result in bugs and regressions.
*   **Accidentally exposing API keys or secrets in client-side code.**

### Edge Cases

*   **Handling errors gracefully:** Implement proper error handling to prevent the application from crashing.
*   **Dealing with different screen sizes:** Ensure the application is responsive and works well on different screen sizes.
*   **Supporting different browsers:** Test the application in different browsers to ensure compatibility.
*   **Managing complex data structures:** Use appropriate data structures and algorithms to efficiently manage complex data.

### Version-Specific Issues

*   **Breaking changes:** Be aware of breaking changes when upgrading Next.js versions.
*   **Deprecated features:** Avoid using deprecated features.
*   **Compatibility with third-party libraries:** Ensure that third-party libraries are compatible with the Next.js version being used.

### Compatibility Concerns

*   **Browser compatibility:** Ensure that the application is compatible with the target browsers.
*   **Third-party library compatibility:** Ensure that third-party libraries are compatible with Next.js.